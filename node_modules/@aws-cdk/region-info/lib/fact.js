"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FactName = exports.Fact = void 0;
const jsiiDeprecationWarnings = require("../.warnings.jsii.js");
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const aws_entities_1 = require("./aws-entities");
const CONSTRUCT_ERROR_SYMBOL = Symbol.for('@aws-cdk/core.SynthesisError');
/**
 * An error thrown when a region fact operation fails.
 */
class RegionFactError extends Error {
    constructor(msg) {
        super(msg);
        Object.setPrototypeOf(this, RegionFactError.prototype);
        Object.defineProperty(this, CONSTRUCT_ERROR_SYMBOL, { value: true });
        this.name = 'RegionFactError';
    }
}
/**
 * A database of regional information.
 */
class Fact {
    static [JSII_RTTI_SYMBOL_1] = { fqn: "@aws-cdk/region-info.Fact", version: "2.235.0" };
    /**
     * @returns the list of names of AWS Regions for which there is at least one registered fact. This
     *          includes Regions defined in AWS_REGIONS plus custom defined regions.
     */
    static get regions() {
        // Return the union of regions in AWS_REGIONS and custom defined regions.
        return [...new Set([...aws_entities_1.AWS_REGIONS, ...Object.keys(this.database)])];
    }
    /**
     * Returns the list of names of registered facts.
     *
     * All facts will be present in at least one region.
     */
    static get names() {
        return [...new Set(Object.values(this.database).flatMap(regionFacts => Object.keys(regionFacts)))];
    }
    /**
     * Return all pairs of (region, factName) that are defined
     */
    static definedFacts() {
        return Object.entries(this.database)
            .flatMap(([regionName, regionFacts]) => Object.keys(regionFacts).map((factName) => [regionName, factName]));
    }
    /**
     * Retrieves a fact from this Fact database.
     *
     * @param region the name of the region (e.g: `us-east-1`)
     * @param name   the name of the fact being looked up (see the `FactName` class for details)
     *
     * @returns the fact value if it is known, and `undefined` otherwise.
     */
    static find(region, name) {
        const regionFacts = this.database[region];
        return regionFacts && regionFacts[name];
    }
    /**
     * Retrieve a fact from the Fact database. (retrieval will fail if the specified region or
     * fact name does not exist.)
     *
     * @param region the name of the region (e.g: `us-east-1`)
     * @param name the name of the fact being looked up (see the `FactName` class for details)
     */
    static requireFact(region, name) {
        const foundFact = this.find(region, name);
        if (!foundFact) {
            throw new RegionFactError(`No fact ${name} could be found for region: ${region} and name: ${name}.`);
        }
        return foundFact;
    }
    /**
     * Registers a new fact in this Fact database.
     *
     * @param fact           the new fact to be registered.
     * @param allowReplacing whether new facts can replace existing facts or not.
     */
    static register(fact, allowReplacing = false) {
        try {
            jsiiDeprecationWarnings._aws_cdk_region_info_IFact(fact);
        }
        catch (error) {
            if (process.env.JSII_DEBUG !== "1" && error.name === "DeprecationError") {
                Error.captureStackTrace(error, this.register);
            }
            throw error;
        }
        const regionFacts = this.database[fact.region] || (this.database[fact.region] = {});
        if (fact.name in regionFacts && regionFacts[fact.name] !== fact.value && !allowReplacing) {
            throw new RegionFactError(`Region ${fact.region} already has a fact ${fact.name}, with value ${regionFacts[fact.name]}`);
        }
        if (fact.value !== undefined) {
            regionFacts[fact.name] = fact.value;
        }
    }
    /**
     * Removes a fact from the database.
     * @param region the region for which the fact is to be removed.
     * @param name   the name of the fact to remove.
     * @param value  the value that should be removed (removal will fail if the value is specified, but does not match the
     *               current stored value).
     */
    static unregister(region, name, value) {
        const regionFacts = this.database[region] || {};
        if (name in regionFacts && value && regionFacts[name] !== value) {
            throw new RegionFactError(`Attempted to remove ${name} from ${region} with value ${value}, but the fact's value is ${regionFacts[name]}`);
        }
        delete regionFacts[name];
    }
    static database = {};
    constructor() {
        // this should never happen, so throw a regular error here
        /* eslint-disable-next-line @cdklabs/no-throw-default-error */
        throw new Error('Use the static methods of Fact instead!');
    }
}
exports.Fact = Fact;
/**
 * All standardized fact names.
 */
class FactName {
    static [JSII_RTTI_SYMBOL_1] = { fqn: "@aws-cdk/region-info.FactName", version: "2.235.0" };
    /**
     * The name of the partition for a region (e.g: 'aws', 'aws-cn', ...)
     */
    static PARTITION = 'partition';
    /**
     * The domain suffix for a region (e.g: 'amazonaws.com`)
     */
    static DOMAIN_SUFFIX = 'domainSuffix';
    /**
     * Whether the AWS::CDK::Metadata CloudFormation Resource is available in-region or not. The value is a boolean
     * modelled as `YES` or `NO`.
     */
    static CDK_METADATA_RESOURCE_AVAILABLE = 'cdk:metadata-resource:available';
    /**
     * Whether the given region is an opt-in region or not. The value is a boolean
     * modelled as `YES` or `NO`.
     */
    static IS_OPT_IN_REGION = 'aws:is-opt-in-region';
    /**
     * The endpoint used for hosting S3 static websites
     */
    static S3_STATIC_WEBSITE_ENDPOINT = 's3-static-website:endpoint';
    /**
     * The endpoint used for aliasing S3 static websites in Route 53
     */
    static S3_STATIC_WEBSITE_ZONE_53_HOSTED_ZONE_ID = 's3-static-website:route-53-hosted-zone-id';
    /**
     * The hosted zone ID used by Route 53 to alias a EBS environment endpoint in this region (e.g: Z2O1EMRO9K5GLX)
     */
    static EBS_ENV_ENDPOINT_HOSTED_ZONE_ID = 'ebs-environment:route-53-hosted-zone-id';
    /**
     * The prefix for VPC Endpoint Service names,
     * cn.com.amazonaws.vpce for China regions,
     * com.amazonaws.vpce otherwise.
     */
    static VPC_ENDPOINT_SERVICE_NAME_PREFIX = 'vpcEndpointServiceNamePrefix';
    /**
     * The account for ELBv2 in this region
     */
    static ELBV2_ACCOUNT = 'elbv2Account';
    /**
     * The ID of the AWS account that owns the public ECR repository that contains the
     * AWS Deep Learning Containers images in a given region.
     */
    static DLC_REPOSITORY_ACCOUNT = 'dlcRepositoryAccount';
    /**
     * The ID of the AWS account that owns the public ECR repository that contains the
     * AWS App Mesh Envoy Proxy images in a given region.
     */
    static APPMESH_ECR_ACCOUNT = 'appMeshRepositoryAccount';
    /**
     * The CIDR block used by Amazon Data Firehose servers.
     */
    static FIREHOSE_CIDR_BLOCK = 'firehoseCidrBlock';
    /**
     * The SAML Sign On URL for partition used by IAM SAML Principal
     */
    static SAML_SIGN_ON_URL = 'samlSignOnUrl';
    /**
     * The latest Lambda NodeJS runtime available in a given region.
     */
    static LATEST_NODE_RUNTIME = 'latestNodeRuntime';
    /**
     * The ARN of CloudWatch Lambda Insights for a version (e.g. 1.0.98.0)
     */
    static cloudwatchLambdaInsightsVersion(version, arch) {
        // if we are provided an architecture use that, otherwise
        // default to x86_64 for backwards compatibility
        const suffix = version.split('.').join('_') + `_${arch ?? 'x86_64'}`;
        return `cloudwatch-lambda-insights-version:${suffix}`;
    }
    /**
     * The ARN of AppConfig Lambda Layer for a given version (e.g. 2.0.181)
     * @param version The layer version.
     * @param arch The architecture (optional), defaults to x86_64.
     */
    static appConfigLambdaLayerVersion(version, arch) {
        const suffix = version.split('.').join('_') + `_${arch ?? 'x86_64'}`;
        return `appconfig-lambda-layer:${suffix}`;
    }
    /**
     * The name of the regional service principal for a given service.
     *
     * @param service the service name, either simple (e.g: `s3`, `codedeploy`) or qualified (e.g: `s3.amazonaws.com`).
     *                The `.amazonaws.com` and `.amazonaws.com.cn` domains are stripped from service names, so they are
     *                canonicalized in that respect.
     *
     * @deprecated - Use `iam.ServicePrincipal.servicePrincipalName()` instead.
     */
    static servicePrincipal(service) {
        try {
            jsiiDeprecationWarnings.print("@aws-cdk/region-info.FactName#servicePrincipal", "- Use `iam.ServicePrincipal.servicePrincipalName()` instead.");
        }
        catch (error) {
            if (process.env.JSII_DEBUG !== "1" && error.name === "DeprecationError") {
                Error.captureStackTrace(error, this.servicePrincipal);
            }
            throw error;
        }
        return `${service.replace(/\.amazonaws\.com(\.cn)?$/, '')}.amazonaws.com`;
    }
    /**
     * The ARN of Amazon Distro for OpenTelemetry (ADOT) Lambda layer for a given lambda type, version and architecture.
     *
     * @param type the type of the ADOT lambda layer
     * @param version the layer version.
     * @param architecture the Lambda Function architecture (e.g. 'x86_64' or 'arm64')
     */
    static adotLambdaLayer(type, version, architecture) {
        const suffix = type + '_' + version.split('.').join('_') + '_' + architecture;
        return `adot-lambda-layer:${suffix}`;
    }
    /**
     * The ARN of Parameters and Secrets Lambda layer for a given lambda architecture.
     *
     * @param version the layer version
     * @param architecture the Lambda Function architecture (e.g. 'x86_64' or 'arm64')
     */
    static paramsAndSecretsLambdaLayer(version, architecture) {
        const suffix = version.split('.').join('_') + `_${architecture}`;
        return `params-and-secrets-layer:${suffix}`;
    }
}
exports.FactName = FactName;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFjdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImZhY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxpREFBNkM7QUFFN0MsTUFBTSxzQkFBc0IsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLDhCQUE4QixDQUFDLENBQUM7QUFFMUU7O0dBRUc7QUFDSCxNQUFNLGVBQWdCLFNBQVEsS0FBSztJQUNqQyxZQUFZLEdBQVc7UUFDckIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ1gsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsZUFBZSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3ZELE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLHNCQUFzQixFQUFFLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFDckUsSUFBSSxDQUFDLElBQUksR0FBRyxpQkFBaUIsQ0FBQztLQUMvQjtDQUNGO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLElBQUk7O0lBQ2Y7OztPQUdHO0lBQ0ksTUFBTSxLQUFLLE9BQU87UUFDdkIseUVBQXlFO1FBQ3pFLE9BQU8sQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRywwQkFBVyxFQUFFLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDdEU7SUFFRDs7OztPQUlHO0lBQ0ksTUFBTSxLQUFLLEtBQUs7UUFDckIsT0FBTyxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNwRztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLFlBQVk7UUFDeEIsT0FBTyxNQUFNLENBQUMsT0FB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QUMsT0FBZSxFQUFFLElBQWE7UUFDdEUsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxJQUFJLElBQUksUUFBUSxFQUFFLENBQUM7UUFDckUsT0FBTywwQkFBMEIsTUFBTSxFQUFFLENBQUM7S0FDM0M7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFlOzs7Ozs7Ozs7O1FBQzVDLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDLDBCQUEwQixFQUFFLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQztLQUMzRTtJQUVEOzs7Ozs7T0FNRztJQUNJLE1BQU0sQ0FBQyxlQUFlLENBQUMsSUFBWSxFQUFFLE9BQWUsRUFBRSxZQUFvQjtRQUMvRSxNQUFNLE1BQU0sR0FBRyxJQUFJLEdBQUcsR0FBRyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxZQUFZLENBQUM7UUFDOUUsT0FBTyxxQkFBcUIsTUFBTSxFQUFFLENBQUM7S0FDdEM7SUFFRDs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBQywyQkFBMkIsQ0FBQyxPQUFlLEVBQUUsWUFBb0I7UUFDN0UsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUNqRSxPQUFPLDRCQUE0QixNQUFNLEVBQUUsQ0FBQztLQUM3Qzs7QUFuSUgsNEJBb0lDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQVdTX1JFR0lPTlMgfSBmcm9tICcuL2F3cy1lbnRpdGllcyc7XG5cbmNvbnN0IENPTlNUUlVDVF9FUlJPUl9TWU1CT0wgPSBTeW1ib2wuZm9yKCdAYXdzLWNkay9jb3JlLlN5bnRoZXNpc0Vycm9yJyk7XG5cbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYSByZWdpb24gZmFjdCBvcGVyYXRpb24gZmFpbHMuXG4gKi9cbmNsYXNzIFJlZ2lvbkZhY3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobXNnOiBzdHJpbmcpIHtcbiAgICBzdXBlcihtc2cpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBSZWdpb25GYWN0RXJyb3IucHJvdG90eXBlKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgQ09OU1RSVUNUX0VSUk9SX1NZTUJPTCwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICB0aGlzLm5hbWUgPSAnUmVnaW9uRmFjdEVycm9yJztcbiAgfVxufVxuXG4vKipcbiAqIEEgZGF0YWJhc2Ugb2YgcmVnaW9uYWwgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBGYWN0IHtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHRoZSBsaXN0IG9mIG5hbWVzIG9mIEFXUyBSZWdpb25zIGZvciB3aGljaCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgcmVnaXN0ZXJlZCBmYWN0LiBUaGlzXG4gICAqICAgICAgICAgIGluY2x1ZGVzIFJlZ2lvbnMgZGVmaW5lZCBpbiBBV1NfUkVHSU9OUyBwbHVzIGN1c3RvbSBkZWZpbmVkIHJlZ2lvbnMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldCByZWdpb25zKCk6IHN0cmluZ1tdIHtcbiAgICAvLyBSZXR1cm4gdGhlIHVuaW9uIG9mIHJlZ2lvbnMgaW4gQVdTX1JFR0lPTlMgYW5kIGN1c3RvbSBkZWZpbmVkIHJlZ2lvbnMuXG4gICAgcmV0dXJuIFsuLi5uZXcgU2V0KFsuLi5BV1NfUkVHSU9OUywgLi4uT2JqZWN0LmtleXModGhpcy5kYXRhYmFzZSldKV07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBuYW1lcyBvZiByZWdpc3RlcmVkIGZhY3RzLlxuICAgKlxuICAgKiBBbGwgZmFjdHMgd2lsbCBiZSBwcmVzZW50IGluIGF0IGxlYXN0IG9uZSByZWdpb24uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldCBuYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFsuLi5uZXcgU2V0KE9iamVjdC52YWx1ZXModGhpcy5kYXRhYmFzZSkuZmxhdE1hcChyZWdpb25GYWN0cyA9PiBPYmplY3Qua2V5cyhyZWdpb25GYWN0cykpKV07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFsbCBwYWlycyBvZiAocmVnaW9uLCBmYWN0TmFtZSkgdGhhdCBhcmUgZGVmaW5lZFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBkZWZpbmVkRmFjdHMoKTogQXJyYXk8c3RyaW5nW10+IHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy5kYXRhYmFzZSlcbiAgICAgIC5mbGF0TWFwKChbcmVnaW9uTmFtZSwgcmVnaW9uRmFjdHNdKSA9PlxuICAgICAgICBPYmplY3Qua2V5cyhyZWdpb25GYWN0cykubWFwKChmYWN0TmFtZSkgPT5cbiAgICAgICAgICBbcmVnaW9uTmFtZSwgZmFjdE5hbWVdIHNhdGlzZmllcyBbc3RyaW5nLCBzdHJpbmddKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgZmFjdCBmcm9tIHRoaXMgRmFjdCBkYXRhYmFzZS5cbiAgICpcbiAgICogQHBhcmFtIHJlZ2lvbiB0aGUgbmFtZSBvZiB0aGUgcmVnaW9uIChlLmc6IGB1cy1lYXN0LTFgKVxuICAgKiBAcGFyYW0gbmFtZSAgIHRoZSBuYW1lIG9mIHRoZSBmYWN0IGJlaW5nIGxvb2tlZCB1cCAoc2VlIHRoZSBgRmFjdE5hbWVgIGNsYXNzIGZvciBkZXRhaWxzKVxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgZmFjdCB2YWx1ZSBpZiBpdCBpcyBrbm93biwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZmluZChyZWdpb246IHN0cmluZywgbmFtZTogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCByZWdpb25GYWN0cyA9IHRoaXMuZGF0YWJhc2VbcmVnaW9uXTtcbiAgICByZXR1cm4gcmVnaW9uRmFjdHMgJiYgcmVnaW9uRmFjdHNbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYSBmYWN0IGZyb20gdGhlIEZhY3QgZGF0YWJhc2UuIChyZXRyaWV2YWwgd2lsbCBmYWlsIGlmIHRoZSBzcGVjaWZpZWQgcmVnaW9uIG9yXG4gICAqIGZhY3QgbmFtZSBkb2VzIG5vdCBleGlzdC4pXG4gICAqXG4gICAqIEBwYXJhbSByZWdpb24gdGhlIG5hbWUgb2YgdGhlIHJlZ2lvbiAoZS5nOiBgdXMtZWFzdC0xYClcbiAgICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZhY3QgYmVpbmcgbG9va2VkIHVwIChzZWUgdGhlIGBGYWN0TmFtZWAgY2xhc3MgZm9yIGRldGFpbHMpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlcXVpcmVGYWN0KHJlZ2lvbjogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGZvdW5kRmFjdCA9IHRoaXMuZmluZChyZWdpb24sIG5hbWUpO1xuXG4gICAgaWYgKCFmb3VuZEZhY3QpIHtcbiAgICAgIHRocm93IG5ldyBSZWdpb25GYWN0RXJyb3IoYE5vIGZhY3QgJHtuYW1lfSBjb3VsZCBiZSBmb3VuZCBmb3IgcmVnaW9uOiAke3JlZ2lvbn0gYW5kIG5hbWU6ICR7bmFtZX0uYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvdW5kRmFjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBuZXcgZmFjdCBpbiB0aGlzIEZhY3QgZGF0YWJhc2UuXG4gICAqXG4gICAqIEBwYXJhbSBmYWN0ICAgICAgICAgICB0aGUgbmV3IGZhY3QgdG8gYmUgcmVnaXN0ZXJlZC5cbiAgICogQHBhcmFtIGFsbG93UmVwbGFjaW5nIHdoZXRoZXIgbmV3IGZhY3RzIGNhbiByZXBsYWNlIGV4aXN0aW5nIGZhY3RzIG9yIG5vdC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXIoZmFjdDogSUZhY3QsIGFsbG93UmVwbGFjaW5nID0gZmFsc2UpOiB2b2lkIHtcbiAgICBjb25zdCByZWdpb25GYWN0cyA9IHRoaXMuZGF0YWJhc2VbZmFjdC5yZWdpb25dIHx8ICh0aGlzLmRhdGFiYXNlW2ZhY3QucmVnaW9uXSA9IHt9KTtcbiAgICBpZiAoZmFjdC5uYW1lIGluIHJlZ2lvbkZhY3RzICYmIHJlZ2lvbkZhY3RzW2ZhY3QubmFtZV0gIT09IGZhY3QudmFsdWUgJiYgIWFsbG93UmVwbGFjaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgUmVnaW9uRmFjdEVycm9yKGBSZWdpb24gJHtmYWN0LnJlZ2lvbn0gYWxyZWFkeSBoYXMgYSBmYWN0ICR7ZmFjdC5uYW1lfSwgd2l0aCB2YWx1ZSAke3JlZ2lvbkZhY3RzW2ZhY3QubmFtZV19YCk7XG4gICAgfVxuICAgIGlmIChmYWN0LnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlZ2lvbkZhY3RzW2ZhY3QubmFtZV0gPSBmYWN0LnZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgZmFjdCBmcm9tIHRoZSBkYXRhYmFzZS5cbiAgICogQHBhcmFtIHJlZ2lvbiB0aGUgcmVnaW9uIGZvciB3aGljaCB0aGUgZmFjdCBpcyB0byBiZSByZW1vdmVkLlxuICAgKiBAcGFyYW0gbmFtZSAgIHRoZSBuYW1lIG9mIHRoZSBmYWN0IHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIHZhbHVlICB0aGUgdmFsdWUgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZCAocmVtb3ZhbCB3aWxsIGZhaWwgaWYgdGhlIHZhbHVlIGlzIHNwZWNpZmllZCwgYnV0IGRvZXMgbm90IG1hdGNoIHRoZVxuICAgKiAgICAgICAgICAgICAgIGN1cnJlbnQgc3RvcmVkIHZhbHVlKS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgdW5yZWdpc3RlcihyZWdpb246IHN0cmluZywgbmFtZTogc3RyaW5nLCB2YWx1ZT86IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IHJlZ2lvbkZhY3RzID0gdGhpcy5kYXRhYmFzZVtyZWdpb25dIHx8IHt9O1xuICAgIGlmIChuYW1lIGluIHJlZ2lvbkZhY3RzICYmIHZhbHVlICYmIHJlZ2lvbkZhY3RzW25hbWVdICE9PSB2YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IFJlZ2lvbkZhY3RFcnJvcihgQXR0ZW1wdGVkIHRvIHJlbW92ZSAke25hbWV9IGZyb20gJHtyZWdpb259IHdpdGggdmFsdWUgJHt2YWx1ZX0sIGJ1dCB0aGUgZmFjdCdzIHZhbHVlIGlzICR7cmVnaW9uRmFjdHNbbmFtZV19YCk7XG4gICAgfVxuICAgIGRlbGV0ZSByZWdpb25GYWN0c1tuYW1lXTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGRhdGFiYXNlOiB7IFtyZWdpb246IHN0cmluZ106IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9IH0gPSB7fTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgc28gdGhyb3cgYSByZWd1bGFyIGVycm9yIGhlcmVcbiAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvbm8tdGhyb3ctZGVmYXVsdC1lcnJvciAqL1xuICAgIHRocm93IG5ldyBFcnJvcignVXNlIHRoZSBzdGF0aWMgbWV0aG9kcyBvZiBGYWN0IGluc3RlYWQhJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGZhY3QgdGhhdCBjYW4gYmUgcmVnaXN0ZXJlZCBhYm91dCBhIHBhcnRpY3VsYXIgcmVnaW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElGYWN0IHtcbiAgLyoqXG4gICAqIFRoZSByZWdpb24gZm9yIHdoaWNoIHRoaXMgZmFjdCBhcHBsaWVzLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVnaW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoaXMgZmFjdC4gU3RhbmRhcmRpemVkIHZhbHVlcyBhcmUgcHJvdmlkZWQgYnkgdGhlIGBGYWN0c2AgY2xhc3MuXG4gICAqL1xuICByZWFkb25seSBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGlzIGZhY3QuXG4gICAqL1xuICByZWFkb25seSB2YWx1ZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEFsbCBzdGFuZGFyZGl6ZWQgZmFjdCBuYW1lcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZhY3ROYW1lIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBwYXJ0aXRpb24gZm9yIGEgcmVnaW9uIChlLmc6ICdhd3MnLCAnYXdzLWNuJywgLi4uKVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBQQVJUSVRJT04gPSAncGFydGl0aW9uJztcblxuICAvKipcbiAgICogVGhlIGRvbWFpbiBzdWZmaXggZm9yIGEgcmVnaW9uIChlLmc6ICdhbWF6b25hd3MuY29tYClcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgRE9NQUlOX1NVRkZJWCA9ICdkb21haW5TdWZmaXgnO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBBV1M6OkNESzo6TWV0YWRhdGEgQ2xvdWRGb3JtYXRpb24gUmVzb3VyY2UgaXMgYXZhaWxhYmxlIGluLXJlZ2lvbiBvciBub3QuIFRoZSB2YWx1ZSBpcyBhIGJvb2xlYW5cbiAgICogbW9kZWxsZWQgYXMgYFlFU2Agb3IgYE5PYC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQ0RLX01FVEFEQVRBX1JFU09VUkNFX0FWQUlMQUJMRSA9ICdjZGs6bWV0YWRhdGEtcmVzb3VyY2U6YXZhaWxhYmxlJztcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgZ2l2ZW4gcmVnaW9uIGlzIGFuIG9wdC1pbiByZWdpb24gb3Igbm90LiBUaGUgdmFsdWUgaXMgYSBib29sZWFuXG4gICAqIG1vZGVsbGVkIGFzIGBZRVNgIG9yIGBOT2AuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IElTX09QVF9JTl9SRUdJT04gPSAnYXdzOmlzLW9wdC1pbi1yZWdpb24nO1xuXG4gIC8qKlxuICAgKiBUaGUgZW5kcG9pbnQgdXNlZCBmb3IgaG9zdGluZyBTMyBzdGF0aWMgd2Vic2l0ZXNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUzNfU1RBVElDX1dFQlNJVEVfRU5EUE9JTlQgPSAnczMtc3RhdGljLXdlYnNpdGU6ZW5kcG9pbnQnO1xuXG4gIC8qKlxuICAgKiBUaGUgZW5kcG9pbnQgdXNlZCBmb3IgYWxpYXNpbmcgUzMgc3RhdGljIHdlYnNpdGVzIGluIFJvdXRlIDUzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFMzX1NUQVRJQ19XRUJTSVRFX1pPTkVfNTNfSE9TVEVEX1pPTkVfSUQgPSAnczMtc3RhdGljLXdlYnNpdGU6cm91dGUtNTMtaG9zdGVkLXpvbmUtaWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgaG9zdGVkIHpvbmUgSUQgdXNlZCBieSBSb3V0ZSA1MyB0byBhbGlhcyBhIEVCUyBlbnZpcm9ubWVudCBlbmRwb2ludCBpbiB0aGlzIHJlZ2lvbiAoZS5nOiBaMk8xRU1STzlLNUdMWClcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgRUJTX0VOVl9FTkRQT0lOVF9IT1NURURfWk9ORV9JRCA9ICdlYnMtZW52aXJvbm1lbnQ6cm91dGUtNTMtaG9zdGVkLXpvbmUtaWQnO1xuXG4gIC8qKlxuICAgKiBUaGUgcHJlZml4IGZvciBWUEMgRW5kcG9pbnQgU2VydmljZSBuYW1lcyxcbiAgICogY24uY29tLmFtYXpvbmF3cy52cGNlIGZvciBDaGluYSByZWdpb25zLFxuICAgKiBjb20uYW1hem9uYXdzLnZwY2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBWUENfRU5EUE9JTlRfU0VSVklDRV9OQU1FX1BSRUZJWCA9ICd2cGNFbmRwb2ludFNlcnZpY2VOYW1lUHJlZml4JztcblxuICAvKipcbiAgICogVGhlIGFjY291bnQgZm9yIEVMQnYyIGluIHRoaXMgcmVnaW9uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEVMQlYyX0FDQ09VTlQgPSAnZWxidjJBY2NvdW50JztcblxuICAvKipcbiAgICogVGhlIElEIG9mIHRoZSBBV1MgYWNjb3VudCB0aGF0IG93bnMgdGhlIHB1YmxpYyBFQ1IgcmVwb3NpdG9yeSB0aGF0IGNvbnRhaW5zIHRoZVxuICAgKiBBV1MgRGVlcCBMZWFybmluZyBDb250YWluZXJzIGltYWdlcyBpbiBhIGdpdmVuIHJlZ2lvbi5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgRExDX1JFUE9TSVRPUllfQUNDT1VOVCA9ICdkbGNSZXBvc2l0b3J5QWNjb3VudCc7XG5cbiAgLyoqXG4gICAqIFRoZSBJRCBvZiB0aGUgQVdTIGFjY291bnQgdGhhdCBvd25zIHRoZSBwdWJsaWMgRUNSIHJlcG9zaXRvcnkgdGhhdCBjb250YWlucyB0aGVcbiAgICogQVdTIEFwcCBNZXNoIEVudm95IFByb3h5IGltYWdlcyBpbiBhIGdpdmVuIHJlZ2lvbi5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQVBQTUVTSF9FQ1JfQUNDT1VOVCA9ICdhcHBNZXNoUmVwb3NpdG9yeUFjY291bnQnO1xuXG4gIC8qKlxuICAgKiBUaGUgQ0lEUiBibG9jayB1c2VkIGJ5IEFtYXpvbiBEYXRhIEZpcmVob3NlIHNlcnZlcnMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEZJUkVIT1NFX0NJRFJfQkxPQ0sgPSAnZmlyZWhvc2VDaWRyQmxvY2snO1xuXG4gIC8qKlxuICAgKiBUaGUgU0FNTCBTaWduIE9uIFVSTCBmb3IgcGFydGl0aW9uIHVzZWQgYnkgSUFNIFNBTUwgUHJpbmNpcGFsXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFNBTUxfU0lHTl9PTl9VUkwgPSAnc2FtbFNpZ25PblVybCc7XG5cbiAgLyoqXG4gICAqIFRoZSBsYXRlc3QgTGFtYmRhIE5vZGVKUyBydW50aW1lIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHJlZ2lvbi5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTEFURVNUX05PREVfUlVOVElNRSA9ICdsYXRlc3ROb2RlUnVudGltZSc7XG5cbiAgLyoqXG4gICAqIFRoZSBBUk4gb2YgQ2xvdWRXYXRjaCBMYW1iZGEgSW5zaWdodHMgZm9yIGEgdmVyc2lvbiAoZS5nLiAxLjAuOTguMClcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY2xvdWR3YXRjaExhbWJkYUluc2lnaHRzVmVyc2lvbih2ZXJzaW9uOiBzdHJpbmcsIGFyY2g/OiBzdHJpbmcpIHtcbiAgICAvLyBpZiB3ZSBhcmUgcHJvdmlkZWQgYW4gYXJjaGl0ZWN0dXJlIHVzZSB0aGF0LCBvdGhlcndpc2VcbiAgICAvLyBkZWZhdWx0IHRvIHg4Nl82NCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBjb25zdCBzdWZmaXggPSB2ZXJzaW9uLnNwbGl0KCcuJykuam9pbignXycpICsgYF8ke2FyY2ggPz8gJ3g4Nl82NCd9YDtcbiAgICByZXR1cm4gYGNsb3Vkd2F0Y2gtbGFtYmRhLWluc2lnaHRzLXZlcnNpb246JHtzdWZmaXh9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQVJOIG9mIEFwcENvbmZpZyBMYW1iZGEgTGF5ZXIgZm9yIGEgZ2l2ZW4gdmVyc2lvbiAoZS5nLiAyLjAuMTgxKVxuICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgbGF5ZXIgdmVyc2lvbi5cbiAgICogQHBhcmFtIGFyY2ggVGhlIGFyY2hpdGVjdHVyZSAob3B0aW9uYWwpLCBkZWZhdWx0cyB0byB4ODZfNjQuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFwcENvbmZpZ0xhbWJkYUxheWVyVmVyc2lvbih2ZXJzaW9uOiBzdHJpbmcsIGFyY2g/OiBzdHJpbmcpIHtcbiAgICBjb25zdCBzdWZmaXggPSB2ZXJzaW9uLnNwbGl0KCcuJykuam9pbignXycpICsgYF8ke2FyY2ggPz8gJ3g4Nl82NCd9YDtcbiAgICByZXR1cm4gYGFwcGNvbmZpZy1sYW1iZGEtbGF5ZXI6JHtzdWZmaXh9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcmVnaW9uYWwgc2VydmljZSBwcmluY2lwYWwgZm9yIGEgZ2l2ZW4gc2VydmljZS5cbiAgICpcbiAgICogQHBhcmFtIHNlcnZpY2UgdGhlIHNlcnZpY2UgbmFtZSwgZWl0aGVyIHNpbXBsZSAoZS5nOiBgczNgLCBgY29kZWRlcGxveWApIG9yIHF1YWxpZmllZCAoZS5nOiBgczMuYW1hem9uYXdzLmNvbWApLlxuICAgKiAgICAgICAgICAgICAgICBUaGUgYC5hbWF6b25hd3MuY29tYCBhbmQgYC5hbWF6b25hd3MuY29tLmNuYCBkb21haW5zIGFyZSBzdHJpcHBlZCBmcm9tIHNlcnZpY2UgbmFtZXMsIHNvIHRoZXkgYXJlXG4gICAqICAgICAgICAgICAgICAgIGNhbm9uaWNhbGl6ZWQgaW4gdGhhdCByZXNwZWN0LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCAtIFVzZSBgaWFtLlNlcnZpY2VQcmluY2lwYWwuc2VydmljZVByaW5jaXBhbE5hbWUoKWAgaW5zdGVhZC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc2VydmljZVByaW5jaXBhbChzZXJ2aWNlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHtzZXJ2aWNlLnJlcGxhY2UoL1xcLmFtYXpvbmF3c1xcLmNvbShcXC5jbik/JC8sICcnKX0uYW1hem9uYXdzLmNvbWA7XG4gIH1cblxuICAvKipcbiAgICogVGhlIEFSTiBvZiBBbWF6b24gRGlzdHJvIGZvciBPcGVuVGVsZW1ldHJ5IChBRE9UKSBMYW1iZGEgbGF5ZXIgZm9yIGEgZ2l2ZW4gbGFtYmRhIHR5cGUsIHZlcnNpb24gYW5kIGFyY2hpdGVjdHVyZS5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgdGhlIHR5cGUgb2YgdGhlIEFET1QgbGFtYmRhIGxheWVyXG4gICAqIEBwYXJhbSB2ZXJzaW9uIHRoZSBsYXllciB2ZXJzaW9uLlxuICAgKiBAcGFyYW0gYXJjaGl0ZWN0dXJlIHRoZSBMYW1iZGEgRnVuY3Rpb24gYXJjaGl0ZWN0dXJlIChlLmcuICd4ODZfNjQnIG9yICdhcm02NCcpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFkb3RMYW1iZGFMYXllcih0eXBlOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZywgYXJjaGl0ZWN0dXJlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHN1ZmZpeCA9IHR5cGUgKyAnXycgKyB2ZXJzaW9uLnNwbGl0KCcuJykuam9pbignXycpICsgJ18nICsgYXJjaGl0ZWN0dXJlO1xuICAgIHJldHVybiBgYWRvdC1sYW1iZGEtbGF5ZXI6JHtzdWZmaXh9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQVJOIG9mIFBhcmFtZXRlcnMgYW5kIFNlY3JldHMgTGFtYmRhIGxheWVyIGZvciBhIGdpdmVuIGxhbWJkYSBhcmNoaXRlY3R1cmUuXG4gICAqXG4gICAqIEBwYXJhbSB2ZXJzaW9uIHRoZSBsYXllciB2ZXJzaW9uXG4gICAqIEBwYXJhbSBhcmNoaXRlY3R1cmUgdGhlIExhbWJkYSBGdW5jdGlvbiBhcmNoaXRlY3R1cmUgKGUuZy4gJ3g4Nl82NCcgb3IgJ2FybTY0JylcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcGFyYW1zQW5kU2VjcmV0c0xhbWJkYUxheWVyKHZlcnNpb246IHN0cmluZywgYXJjaGl0ZWN0dXJlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHN1ZmZpeCA9IHZlcnNpb24uc3BsaXQoJy4nKS5qb2luKCdfJykgKyBgXyR7YXJjaGl0ZWN0dXJlfWA7XG4gICAgcmV0dXJuIGBwYXJhbXMtYW5kLXNlY3JldHMtbGF5ZXI6JHtzdWZmaXh9YDtcbiAgfVxufVxuIl19